{"version":3,"sources":["../src/utils.js"],"names":["defer","splitPath","eachSeries","foreach","doIf","asyncWhile","resolve","reject","promise","Promise","success","failure","path","result","components","split","forEach","number","parseInt","element","isNaN","length","push","arr","fun","reduce","p","e","then","callback","iterate","index","array","res","condition","predicate","pkB58Prefix","curve","Buffer","of","pkhB58Prefix","compressPublicKey","publicKey","slice","concat","encodePublicKey","publicKeyToString","address","hashPublicKeyToString","key","encode","keyHashSize","hash","update","digest"],"mappings":"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","file":"utils.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\nimport bs58check from 'bs58check';\nimport blake2b from 'blake2b';\n\ntype Defer<T> = {\n  promise: Promise<T>,\n  resolve: T => void,\n  reject: any => void\n};\n\nexport function defer<T>(): Defer<T> {\n  let resolve, reject;\n  let promise = new Promise(function(success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n  return { promise, resolve, reject };\n}\n\n// TODO use bip32-path library\nexport function splitPath(path: string): number[] {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\n// TODO use async await\n\nexport function eachSeries<A>(arr: A[], fun: A => Promise<*>): Promise<*> {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\n\nexport function foreach<T, A>(\n  arr: T[],\n  callback: (T, number) => Promise<A>\n): Promise<A[]> {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else\n      return callback(array[index], index).then(function(res) {\n        result.push(res);\n        return iterate(index + 1, array, result);\n      });\n  }\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\n\nexport function doIf(\n  condition: boolean,\n  callback: () => any | Promise<any>\n): Promise<void> {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\n\nexport function asyncWhile<T>(\n  predicate: () => boolean,\n  callback: () => Promise<T>\n): Promise<Array<T>> {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then(res => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n  return Promise.resolve([]).then(iterate);\n}\n\nconst pkB58Prefix = curve => {\n  switch (curve) {\n  // edpk\n  case 0x00:\n    return Buffer.of(13, 15, 37, 217);\n  // sppk\n  case 0x01:\n    return Buffer.of(3, 254, 226, 86);\n  // p2pk\n  case 0x02:\n    return Buffer.of(3, 178, 139, 127);\n  }\n};\n\nconst pkhB58Prefix = curve => {\n  switch (curve) {\n  // tz1\n  case 0x00:\n    return Buffer.of(6, 161, 159);\n  // tz2\n  case 0x01:\n    return Buffer.of(6, 161, 161);\n  // tz3\n  case 0x02:\n    return Buffer.of(6, 161, 164);\n  }\n};\n\n// converts uncompressed ledger key to standard tezos binary\n// representation, with curve marker first byte (as for michelson key\n// type)\nconst compressPublicKey = (publicKey, curve) => {\n  switch (curve) {\n  // Ed25519\n  case 0x00:\n    publicKey = publicKey.slice(0);\n    publicKey[0] = curve;\n    return publicKey;\n  // SECP256K1, SECP256R1\n  case 0x01:\n  case 0x02:\n    return Buffer.concat([\n      Buffer.of(\n        curve,\n        0x02 + (publicKey[64] & 0x01),\n      ),\n      publicKey.slice(1, 33),\n    ]);\n  }\n};\n\nexport const encodePublicKey = (publicKey, curve) => {\n  publicKey = compressPublicKey(publicKey, curve);\n  return {\n    publicKey: publicKeyToString(publicKey),\n    address: hashPublicKeyToString(publicKey),\n  };\n};\n\n// remaining functions operate on tezos compressed key w/ curve marker\n\nconst publicKeyToString = publicKey => {\n  const curve = publicKey[0];\n  const key = publicKey.slice(1);\n  return bs58check.encode(Buffer.concat([pkB58Prefix(curve), key]));\n};\n\nconst keyHashSize = 20;\n\nconst hashPublicKeyToString = publicKey => {\n  const curve = publicKey[0];\n  const key = publicKey.slice(1);\n  let hash = blake2b(keyHashSize);\n  hash.update(key);\n  hash.digest(hash = new Buffer(keyHashSize));\n  return bs58check.encode(Buffer.concat([pkhB58Prefix(curve), hash]));\n};\n"]}